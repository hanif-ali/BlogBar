import json
from datetime import datetime, time


########  ######## ########  ########  ########  ######     ###    ######## ######## ########
##     ## ##       ##     ## ##     ## ##       ##    ##   ## ##      ##    ##       ##     ##
##     ## ##       ##     ## ##     ## ##       ##        ##   ##     ##    ##       ##     ##
##     ## ######   ########  ########  ######   ##       ##     ##    ##    ######   ##     ##
##     ## ##       ##        ##   ##   ##       ##       #########    ##    ##       ##     ##
##     ## ##       ##        ##    ##  ##       ##    ## ##     ##    ##    ##       ##     ##
########  ######## ##        ##     ## ########  ######  ##     ##    ##    ######## ########


def use_json(insert_function):
    """
    DECORATOR
    :param insert_function:  this is the function that will be called using the jsonObejct (as dictionary) as second
    parameter by this decorator
    :return: the inner function ==> execution of the following procedure:
        1. loading the json as dict
        2. manipulating the dict using the passed function
        3. writing the manipulated json-object back (persistence)
    """

    def execution(data: dict, json_obj=None):
        with open("/Users/benwegener/Library/Mobile Documents/com~apple~CloudDocs/BlogBar/"
                  "BlogBar-webapplication/Core/admin/files/tracking.json", mode="r") as file:
            dictionary = json.load(file)

        result = insert_function(data, dictionary)

        with open("/Users/benwegener/Library/Mobile Documents/com~apple~CloudDocs/BlogBar/"
                  "BlogBar-webapplication/Core/admin/files/tracking.json", mode="w") as file:
            file.write(json.dumps(result))

    return execution


@use_json
def add_private_camapaign_creation_to_analysis_json(data: dict, json_obj: dict = None) -> dict:
    """

    :param data:
    :param json_obj:
    :return:
    """
    json_obj["private_campaigns"].append(
        {
            "timestamp": get_current_timestamp()
        }
    )

    return json_obj


@use_json
def add_stored_search_to_analysis_json(data: dict, json_obj: dict = None) -> dict:
    """

    :param data:
    :param json_obj:
    :return:
    """
    json_obj["stored_searches"].append(
        {
            "timestamp": get_current_timestamp()
        }
    )

    return json_obj


@use_json
def add_public_campaign_to_analysis_json(data: dict, json_obj: dict = None) -> dict:
    """

    :param data:
    :param json_obj:
    :return:
    """
    json_obj["public_campaigns"].append(
        {
            "timestamp": get_current_timestamp()
        }
    )

    return json_obj


@use_json
def add_sign_out_permanatly_to_analysis_json(data: dict, json_obj: dict = None) -> dict:
    """

    :param data: required params are: kind and identifier (both are stored in the Flask-session)
    :param json_obj: generated by the decorator; decorator writes the changes also into the .json-file
    :return: dict - decorator stores this dict as json-dump in a json-file
    """
    if data.get("kind", 1) == 1:
        json_obj["sign_outs"]["influencer"].append(
            {
                "timestamp": get_current_timestamp(),
                "id": data.get("identifier", None)
            }
        )
    else:
        json_obj["sign_outs"]["companies"].append(
            {
                "timestamp": get_current_timestamp(),
                "id": data.get("identifier", None)
            }
        )

    return json_obj


@use_json
def add_search_to_analysis_json(data: dict, json_obj: dict = None) -> dict:
    """

    :param data: required params are: kind and identifier (both are stored in the Flask-session)
    :param json_obj: generated by the decorator; decorator writes the changes also into the .json-file
    :return: dict - decorator stores this dict as json-dump in a json-file
    """
    json_obj["searches"].append(
        {
            "timestamp": get_current_timestamp(),
            "package": data.get("package", "basic"),
            "channel": data.get("channel", None)
        }
    )

    return json_obj


@use_json
def add_sign_ups_to_analysis_json(data: dict, json_obj: dict = None) -> dict:
    """

    :param data: required params are: kind and identifier (both are stored in the Flask-session)
    :param json_obj: generated by the decorator; decorator writes the changes also into the .json-file
    :return: dict - decorator stores this dict as json-dump in a json-file
    """
    if data.get("kind", 1) == 1:
        json_obj["sign_ups"]["influencer"].append(
            {
                "timestamp": get_current_timestamp(),
                "id": data.get("identifier", None)
            }
        )
    else:
        json_obj["sign_ups"]["companies"].append(
            {
                "timestamp": get_current_timestamp(),
                "id": data.get("identifier", None)
            }
        )

    return json_obj


@use_json
def add_sign_ins_to_analysis_json(data: dict, json_obj: dict = None) -> dict:
    """

    :param data: required params are: kind and identifier (both are stored in the Flask-session)
    :param json_obj: generated by the decorator; decorator writes the changes also into the .json-file
    :return: dict - decorator stores this dict as json-dump in a json-file
    """
    if data.get("kind", 1) == 1:
        json_obj["sign_ins"]["influencer"].append(
            {
                "timestamp": get_current_timestamp(),
                "id": data.get("identifier", None)
            }
        )
    else:
        json_obj["sign_ins"]["companies"].append(
            {
                "timestamp": get_current_timestamp(),
                "id": data.get("identifier", None)
            }
        )

    return json_obj


def get_current_timestamp() -> float:
    """

    :return: This function returns the current TimeStamp
    """
    from datetime import datetime

    now = datetime.now()
    timestamp = datetime.timestamp(now)

    return timestamp


def parse_timestamp(timestamp):
    """

    :param timestamp: float (common timestamp)
    :return: datetime--object that is computed using the passed timestamp
    """
    dt_object = datetime.fromtimestamp(timestamp)

    return dt_object

# Testinsertions:
